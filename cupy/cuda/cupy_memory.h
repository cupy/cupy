#ifndef INCLUDE_GUARD_CUPY_CUDA_MEMORY_H
#define INCLUDE_GUARD_CUPY_CUDA_MEMORY_H

#include "memory_api.h"  // generated by Cython from cupy.cuda.memory

class cupy_device_allocator {
private:
    int is_init;
    void* (*_malloc)(size_t);
    void (*_free)(void*);

public:
/*
    To use this utility, the lifetime of this allocator instance should
    be as long as your shared library or application. Early destruction
    would lead to segfault!

    If this piece of code is already embedded in a Python application,
    we skip calling Py_Initialize() at construction and Py_Finalize()
    at deconstruction.
*/
    cupy_device_allocator() {
        is_init = Py_IsInitialized();
        if (!is_init) {
            Py_Initialize();
        }
        import_cupy__cuda__memory();
        _malloc = cupy_c_malloc; // defined in cupy.cuda.memory
        _free = cupy_c_free;     // defined in cupy.cuda.memory
    }

    ~cupy_device_allocator() {
        _malloc = nullptr;
        _free = nullptr;
        if (!is_init) {
            Py_Finalize();
        }
    }

    void* malloc(size_t n_bytes) {
        void* ptr = _malloc(n_bytes);
        return ptr;
    }
    
    void free(void* ptr) {
        _free(ptr);
    }
};

#ifdef __cplusplus
extern "C" {
#endif

struct cupy_allocator_handle_t;
typedef struct cupy_allocator_handle_t cupy_allocator_handle;

cupy_allocator_handle* get_cupy_allocator_handle() {
    cupy_allocator_handle* alloc = (cupy_allocator_handle*)(new cupy_device_allocator());
    return alloc;
}

void destroy_cupy_allocator_handle(cupy_allocator_handle* ptr) {
    cupy_device_allocator* alloc = (cupy_device_allocator*)ptr;
    delete alloc;
}

void* cupy_malloc(cupy_allocator_handle* handle, size_t size) {
    return ((cupy_device_allocator*)handle)->malloc(size);
}

void cupy_free(cupy_allocator_handle* handle, void* ptr) {
    ((cupy_device_allocator*)handle)->free(ptr);
}

#ifdef __cplusplus
}
#endif
    
#endif // #ifndef INCLUDE_GUARD_CUPY_CUDA_MEMORY_H
