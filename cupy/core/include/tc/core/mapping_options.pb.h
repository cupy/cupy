// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mapping_options.proto

#ifndef PROTOBUF_mapping_5foptions_2eproto__INCLUDED
#define PROTOBUF_mapping_5foptions_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace tc {
class CudaDimProto;
class CudaDimProtoDefaultTypeInternal;
extern CudaDimProtoDefaultTypeInternal _CudaDimProto_default_instance_;
class MappingOptionsProto;
class MappingOptionsProtoDefaultTypeInternal;
extern MappingOptionsProtoDefaultTypeInternal _MappingOptionsProto_default_instance_;
class SchedulerOptionsProto;
class SchedulerOptionsProtoDefaultTypeInternal;
extern SchedulerOptionsProtoDefaultTypeInternal _SchedulerOptionsProto_default_instance_;
class TilingProto;
class TilingProtoDefaultTypeInternal;
extern TilingProtoDefaultTypeInternal _TilingProto_default_instance_;
}  // namespace tc

namespace tc {

namespace protobuf_mapping_5foptions_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mapping_5foptions_2eproto

enum FusionStrategy {
  Max = 1,
  Preserve3Coincident = 2,
  Min = 3
};
bool FusionStrategy_IsValid(int value);
const FusionStrategy FusionStrategy_MIN = Max;
const FusionStrategy FusionStrategy_MAX = Min;
const int FusionStrategy_ARRAYSIZE = FusionStrategy_MAX + 1;

const ::google::protobuf::EnumDescriptor* FusionStrategy_descriptor();
inline const ::std::string& FusionStrategy_Name(FusionStrategy value) {
  return ::google::protobuf::internal::NameOfEnum(
    FusionStrategy_descriptor(), value);
}
inline bool FusionStrategy_Parse(
    const ::std::string& name, FusionStrategy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FusionStrategy>(
    FusionStrategy_descriptor(), name, value);
}
// ===================================================================

class CudaDimProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tc.CudaDimProto) */ {
 public:
  CudaDimProto();
  virtual ~CudaDimProto();

  CudaDimProto(const CudaDimProto& from);

  inline CudaDimProto& operator=(const CudaDimProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CudaDimProto(CudaDimProto&& from) noexcept
    : CudaDimProto() {
    *this = ::std::move(from);
  }

  inline CudaDimProto& operator=(CudaDimProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CudaDimProto& default_instance();

  static inline const CudaDimProto* internal_default_instance() {
    return reinterpret_cast<const CudaDimProto*>(
               &_CudaDimProto_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CudaDimProto* other);
  friend void swap(CudaDimProto& a, CudaDimProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CudaDimProto* New() const PROTOBUF_FINAL { return New(NULL); }

  CudaDimProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CudaDimProto& from);
  void MergeFrom(const CudaDimProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CudaDimProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::uint64 x() const;
  void set_x(::google::protobuf::uint64 value);

  // optional uint64 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::uint64 y() const;
  void set_y(::google::protobuf::uint64 value);

  // optional uint64 z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::uint64 z() const;
  void set_z(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tc.CudaDimProto)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 x_;
  ::google::protobuf::uint64 y_;
  ::google::protobuf::uint64 z_;
  friend struct protobuf_mapping_5foptions_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SchedulerOptionsProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tc.SchedulerOptionsProto) */ {
 public:
  SchedulerOptionsProto();
  virtual ~SchedulerOptionsProto();

  SchedulerOptionsProto(const SchedulerOptionsProto& from);

  inline SchedulerOptionsProto& operator=(const SchedulerOptionsProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SchedulerOptionsProto(SchedulerOptionsProto&& from) noexcept
    : SchedulerOptionsProto() {
    *this = ::std::move(from);
  }

  inline SchedulerOptionsProto& operator=(SchedulerOptionsProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchedulerOptionsProto& default_instance();

  static inline const SchedulerOptionsProto* internal_default_instance() {
    return reinterpret_cast<const SchedulerOptionsProto*>(
               &_SchedulerOptionsProto_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SchedulerOptionsProto* other);
  friend void swap(SchedulerOptionsProto& a, SchedulerOptionsProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SchedulerOptionsProto* New() const PROTOBUF_FINAL { return New(NULL); }

  SchedulerOptionsProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SchedulerOptionsProto& from);
  void MergeFrom(const SchedulerOptionsProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SchedulerOptionsProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool allow_skewing = 2;
  bool has_allow_skewing() const;
  void clear_allow_skewing();
  static const int kAllowSkewingFieldNumber = 2;
  bool allow_skewing() const;
  void set_allow_skewing(bool value);

  // required bool positive_orthant = 3;
  bool has_positive_orthant() const;
  void clear_positive_orthant();
  static const int kPositiveOrthantFieldNumber = 3;
  bool positive_orthant() const;
  void set_positive_orthant(bool value);

  // required .tc.FusionStrategy fusion_strategy = 1;
  bool has_fusion_strategy() const;
  void clear_fusion_strategy();
  static const int kFusionStrategyFieldNumber = 1;
  ::tc::FusionStrategy fusion_strategy() const;
  void set_fusion_strategy(::tc::FusionStrategy value);

  // @@protoc_insertion_point(class_scope:tc.SchedulerOptionsProto)
 private:
  void set_has_fusion_strategy();
  void clear_has_fusion_strategy();
  void set_has_allow_skewing();
  void clear_has_allow_skewing();
  void set_has_positive_orthant();
  void clear_has_positive_orthant();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool allow_skewing_;
  bool positive_orthant_;
  int fusion_strategy_;
  friend struct protobuf_mapping_5foptions_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TilingProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tc.TilingProto) */ {
 public:
  TilingProto();
  virtual ~TilingProto();

  TilingProto(const TilingProto& from);

  inline TilingProto& operator=(const TilingProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TilingProto(TilingProto&& from) noexcept
    : TilingProto() {
    *this = ::std::move(from);
  }

  inline TilingProto& operator=(TilingProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TilingProto& default_instance();

  static inline const TilingProto* internal_default_instance() {
    return reinterpret_cast<const TilingProto*>(
               &_TilingProto_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TilingProto* other);
  friend void swap(TilingProto& a, TilingProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TilingProto* New() const PROTOBUF_FINAL { return New(NULL); }

  TilingProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TilingProto& from);
  void MergeFrom(const TilingProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TilingProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 sizes = 1;
  int sizes_size() const;
  void clear_sizes();
  static const int kSizesFieldNumber = 1;
  ::google::protobuf::uint64 sizes(int index) const;
  void set_sizes(int index, ::google::protobuf::uint64 value);
  void add_sizes(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      sizes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_sizes();

  // @@protoc_insertion_point(class_scope:tc.TilingProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > sizes_;
  friend struct protobuf_mapping_5foptions_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MappingOptionsProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tc.MappingOptionsProto) */ {
 public:
  MappingOptionsProto();
  virtual ~MappingOptionsProto();

  MappingOptionsProto(const MappingOptionsProto& from);

  inline MappingOptionsProto& operator=(const MappingOptionsProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MappingOptionsProto(MappingOptionsProto&& from) noexcept
    : MappingOptionsProto() {
    *this = ::std::move(from);
  }

  inline MappingOptionsProto& operator=(MappingOptionsProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MappingOptionsProto& default_instance();

  static inline const MappingOptionsProto* internal_default_instance() {
    return reinterpret_cast<const MappingOptionsProto*>(
               &_MappingOptionsProto_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MappingOptionsProto* other);
  friend void swap(MappingOptionsProto& a, MappingOptionsProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MappingOptionsProto* New() const PROTOBUF_FINAL { return New(NULL); }

  MappingOptionsProto* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MappingOptionsProto& from);
  void MergeFrom(const MappingOptionsProto& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MappingOptionsProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tc.SchedulerOptionsProto outer_schedule_options = 1;
  bool has_outer_schedule_options() const;
  void clear_outer_schedule_options();
  static const int kOuterScheduleOptionsFieldNumber = 1;
  const ::tc::SchedulerOptionsProto& outer_schedule_options() const;
  ::tc::SchedulerOptionsProto* mutable_outer_schedule_options();
  ::tc::SchedulerOptionsProto* release_outer_schedule_options();
  void set_allocated_outer_schedule_options(::tc::SchedulerOptionsProto* outer_schedule_options);

  // required .tc.SchedulerOptionsProto intra_tile_schedule_options = 2;
  bool has_intra_tile_schedule_options() const;
  void clear_intra_tile_schedule_options();
  static const int kIntraTileScheduleOptionsFieldNumber = 2;
  const ::tc::SchedulerOptionsProto& intra_tile_schedule_options() const;
  ::tc::SchedulerOptionsProto* mutable_intra_tile_schedule_options();
  ::tc::SchedulerOptionsProto* release_intra_tile_schedule_options();
  void set_allocated_intra_tile_schedule_options(::tc::SchedulerOptionsProto* intra_tile_schedule_options);

  // optional .tc.TilingProto tiling = 4;
  bool has_tiling() const;
  void clear_tiling();
  static const int kTilingFieldNumber = 4;
  const ::tc::TilingProto& tiling() const;
  ::tc::TilingProto* mutable_tiling();
  ::tc::TilingProto* release_tiling();
  void set_allocated_tiling(::tc::TilingProto* tiling);

  // required .tc.CudaDimProto block = 5;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 5;
  const ::tc::CudaDimProto& block() const;
  ::tc::CudaDimProto* mutable_block();
  ::tc::CudaDimProto* release_block();
  void set_allocated_block(::tc::CudaDimProto* block);

  // required .tc.CudaDimProto grid = 6;
  bool has_grid() const;
  void clear_grid();
  static const int kGridFieldNumber = 6;
  const ::tc::CudaDimProto& grid() const;
  ::tc::CudaDimProto* mutable_grid();
  ::tc::CudaDimProto* release_grid();
  void set_allocated_grid(::tc::CudaDimProto* grid);

  // optional uint64 unroll = 7;
  bool has_unroll() const;
  void clear_unroll();
  static const int kUnrollFieldNumber = 7;
  ::google::protobuf::uint64 unroll() const;
  void set_unroll(::google::protobuf::uint64 value);

  // required bool fix_parameters_before_scheduling = 3;
  bool has_fix_parameters_before_scheduling() const;
  void clear_fix_parameters_before_scheduling();
  static const int kFixParametersBeforeSchedulingFieldNumber = 3;
  bool fix_parameters_before_scheduling() const;
  void set_fix_parameters_before_scheduling(bool value);

  // required bool tile_imperfectly_nested = 8;
  bool has_tile_imperfectly_nested() const;
  void clear_tile_imperfectly_nested();
  static const int kTileImperfectlyNestedFieldNumber = 8;
  bool tile_imperfectly_nested() const;
  void set_tile_imperfectly_nested(bool value);

  // required bool use_shared_memory = 9;
  bool has_use_shared_memory() const;
  void clear_use_shared_memory();
  static const int kUseSharedMemoryFieldNumber = 9;
  bool use_shared_memory() const;
  void set_use_shared_memory(bool value);

  // required bool use_private_memory = 10;
  bool has_use_private_memory() const;
  void clear_use_private_memory();
  static const int kUsePrivateMemoryFieldNumber = 10;
  bool use_private_memory() const;
  void set_use_private_memory(bool value);

  // required bool unroll_copy_shared = 11;
  bool has_unroll_copy_shared() const;
  void clear_unroll_copy_shared();
  static const int kUnrollCopySharedFieldNumber = 11;
  bool unroll_copy_shared() const;
  void set_unroll_copy_shared(bool value);

  // required bool match_library_calls = 14;
  bool has_match_library_calls() const;
  void clear_match_library_calls();
  static const int kMatchLibraryCallsFieldNumber = 14;
  bool match_library_calls() const;
  void set_match_library_calls(bool value);

  // optional uint64 max_shared_memory = 12;
  bool has_max_shared_memory() const;
  void clear_max_shared_memory();
  static const int kMaxSharedMemoryFieldNumber = 12;
  ::google::protobuf::uint64 max_shared_memory() const;
  void set_max_shared_memory(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tc.MappingOptionsProto)
 private:
  void set_has_outer_schedule_options();
  void clear_has_outer_schedule_options();
  void set_has_intra_tile_schedule_options();
  void clear_has_intra_tile_schedule_options();
  void set_has_fix_parameters_before_scheduling();
  void clear_has_fix_parameters_before_scheduling();
  void set_has_tiling();
  void clear_has_tiling();
  void set_has_block();
  void clear_has_block();
  void set_has_grid();
  void clear_has_grid();
  void set_has_unroll();
  void clear_has_unroll();
  void set_has_tile_imperfectly_nested();
  void clear_has_tile_imperfectly_nested();
  void set_has_use_shared_memory();
  void clear_has_use_shared_memory();
  void set_has_use_private_memory();
  void clear_has_use_private_memory();
  void set_has_unroll_copy_shared();
  void clear_has_unroll_copy_shared();
  void set_has_max_shared_memory();
  void clear_has_max_shared_memory();
  void set_has_match_library_calls();
  void clear_has_match_library_calls();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::tc::SchedulerOptionsProto* outer_schedule_options_;
  ::tc::SchedulerOptionsProto* intra_tile_schedule_options_;
  ::tc::TilingProto* tiling_;
  ::tc::CudaDimProto* block_;
  ::tc::CudaDimProto* grid_;
  ::google::protobuf::uint64 unroll_;
  bool fix_parameters_before_scheduling_;
  bool tile_imperfectly_nested_;
  bool use_shared_memory_;
  bool use_private_memory_;
  bool unroll_copy_shared_;
  bool match_library_calls_;
  ::google::protobuf::uint64 max_shared_memory_;
  friend struct protobuf_mapping_5foptions_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CudaDimProto

// required uint64 x = 1;
inline bool CudaDimProto::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CudaDimProto::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CudaDimProto::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CudaDimProto::clear_x() {
  x_ = GOOGLE_ULONGLONG(0);
  clear_has_x();
}
inline ::google::protobuf::uint64 CudaDimProto::x() const {
  // @@protoc_insertion_point(field_get:tc.CudaDimProto.x)
  return x_;
}
inline void CudaDimProto::set_x(::google::protobuf::uint64 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tc.CudaDimProto.x)
}

// optional uint64 y = 2;
inline bool CudaDimProto::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CudaDimProto::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CudaDimProto::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CudaDimProto::clear_y() {
  y_ = GOOGLE_ULONGLONG(0);
  clear_has_y();
}
inline ::google::protobuf::uint64 CudaDimProto::y() const {
  // @@protoc_insertion_point(field_get:tc.CudaDimProto.y)
  return y_;
}
inline void CudaDimProto::set_y(::google::protobuf::uint64 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tc.CudaDimProto.y)
}

// optional uint64 z = 3;
inline bool CudaDimProto::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CudaDimProto::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CudaDimProto::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CudaDimProto::clear_z() {
  z_ = GOOGLE_ULONGLONG(0);
  clear_has_z();
}
inline ::google::protobuf::uint64 CudaDimProto::z() const {
  // @@protoc_insertion_point(field_get:tc.CudaDimProto.z)
  return z_;
}
inline void CudaDimProto::set_z(::google::protobuf::uint64 value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:tc.CudaDimProto.z)
}

// -------------------------------------------------------------------

// SchedulerOptionsProto

// required .tc.FusionStrategy fusion_strategy = 1;
inline bool SchedulerOptionsProto::has_fusion_strategy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SchedulerOptionsProto::set_has_fusion_strategy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SchedulerOptionsProto::clear_has_fusion_strategy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SchedulerOptionsProto::clear_fusion_strategy() {
  fusion_strategy_ = 1;
  clear_has_fusion_strategy();
}
inline ::tc::FusionStrategy SchedulerOptionsProto::fusion_strategy() const {
  // @@protoc_insertion_point(field_get:tc.SchedulerOptionsProto.fusion_strategy)
  return static_cast< ::tc::FusionStrategy >(fusion_strategy_);
}
inline void SchedulerOptionsProto::set_fusion_strategy(::tc::FusionStrategy value) {
  assert(::tc::FusionStrategy_IsValid(value));
  set_has_fusion_strategy();
  fusion_strategy_ = value;
  // @@protoc_insertion_point(field_set:tc.SchedulerOptionsProto.fusion_strategy)
}

// required bool allow_skewing = 2;
inline bool SchedulerOptionsProto::has_allow_skewing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SchedulerOptionsProto::set_has_allow_skewing() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SchedulerOptionsProto::clear_has_allow_skewing() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SchedulerOptionsProto::clear_allow_skewing() {
  allow_skewing_ = false;
  clear_has_allow_skewing();
}
inline bool SchedulerOptionsProto::allow_skewing() const {
  // @@protoc_insertion_point(field_get:tc.SchedulerOptionsProto.allow_skewing)
  return allow_skewing_;
}
inline void SchedulerOptionsProto::set_allow_skewing(bool value) {
  set_has_allow_skewing();
  allow_skewing_ = value;
  // @@protoc_insertion_point(field_set:tc.SchedulerOptionsProto.allow_skewing)
}

// required bool positive_orthant = 3;
inline bool SchedulerOptionsProto::has_positive_orthant() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SchedulerOptionsProto::set_has_positive_orthant() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SchedulerOptionsProto::clear_has_positive_orthant() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SchedulerOptionsProto::clear_positive_orthant() {
  positive_orthant_ = false;
  clear_has_positive_orthant();
}
inline bool SchedulerOptionsProto::positive_orthant() const {
  // @@protoc_insertion_point(field_get:tc.SchedulerOptionsProto.positive_orthant)
  return positive_orthant_;
}
inline void SchedulerOptionsProto::set_positive_orthant(bool value) {
  set_has_positive_orthant();
  positive_orthant_ = value;
  // @@protoc_insertion_point(field_set:tc.SchedulerOptionsProto.positive_orthant)
}

// -------------------------------------------------------------------

// TilingProto

// repeated uint64 sizes = 1;
inline int TilingProto::sizes_size() const {
  return sizes_.size();
}
inline void TilingProto::clear_sizes() {
  sizes_.Clear();
}
inline ::google::protobuf::uint64 TilingProto::sizes(int index) const {
  // @@protoc_insertion_point(field_get:tc.TilingProto.sizes)
  return sizes_.Get(index);
}
inline void TilingProto::set_sizes(int index, ::google::protobuf::uint64 value) {
  sizes_.Set(index, value);
  // @@protoc_insertion_point(field_set:tc.TilingProto.sizes)
}
inline void TilingProto::add_sizes(::google::protobuf::uint64 value) {
  sizes_.Add(value);
  // @@protoc_insertion_point(field_add:tc.TilingProto.sizes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
TilingProto::sizes() const {
  // @@protoc_insertion_point(field_list:tc.TilingProto.sizes)
  return sizes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
TilingProto::mutable_sizes() {
  // @@protoc_insertion_point(field_mutable_list:tc.TilingProto.sizes)
  return &sizes_;
}

// -------------------------------------------------------------------

// MappingOptionsProto

// required .tc.SchedulerOptionsProto outer_schedule_options = 1;
inline bool MappingOptionsProto::has_outer_schedule_options() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MappingOptionsProto::set_has_outer_schedule_options() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MappingOptionsProto::clear_has_outer_schedule_options() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MappingOptionsProto::clear_outer_schedule_options() {
  if (outer_schedule_options_ != NULL) outer_schedule_options_->::tc::SchedulerOptionsProto::Clear();
  clear_has_outer_schedule_options();
}
inline const ::tc::SchedulerOptionsProto& MappingOptionsProto::outer_schedule_options() const {
  const ::tc::SchedulerOptionsProto* p = outer_schedule_options_;
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.outer_schedule_options)
  return p != NULL ? *p : *reinterpret_cast<const ::tc::SchedulerOptionsProto*>(
      &::tc::_SchedulerOptionsProto_default_instance_);
}
inline ::tc::SchedulerOptionsProto* MappingOptionsProto::mutable_outer_schedule_options() {
  set_has_outer_schedule_options();
  if (outer_schedule_options_ == NULL) {
    outer_schedule_options_ = new ::tc::SchedulerOptionsProto;
  }
  // @@protoc_insertion_point(field_mutable:tc.MappingOptionsProto.outer_schedule_options)
  return outer_schedule_options_;
}
inline ::tc::SchedulerOptionsProto* MappingOptionsProto::release_outer_schedule_options() {
  // @@protoc_insertion_point(field_release:tc.MappingOptionsProto.outer_schedule_options)
  clear_has_outer_schedule_options();
  ::tc::SchedulerOptionsProto* temp = outer_schedule_options_;
  outer_schedule_options_ = NULL;
  return temp;
}
inline void MappingOptionsProto::set_allocated_outer_schedule_options(::tc::SchedulerOptionsProto* outer_schedule_options) {
  delete outer_schedule_options_;
  outer_schedule_options_ = outer_schedule_options;
  if (outer_schedule_options) {
    set_has_outer_schedule_options();
  } else {
    clear_has_outer_schedule_options();
  }
  // @@protoc_insertion_point(field_set_allocated:tc.MappingOptionsProto.outer_schedule_options)
}

// required .tc.SchedulerOptionsProto intra_tile_schedule_options = 2;
inline bool MappingOptionsProto::has_intra_tile_schedule_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MappingOptionsProto::set_has_intra_tile_schedule_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MappingOptionsProto::clear_has_intra_tile_schedule_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MappingOptionsProto::clear_intra_tile_schedule_options() {
  if (intra_tile_schedule_options_ != NULL) intra_tile_schedule_options_->::tc::SchedulerOptionsProto::Clear();
  clear_has_intra_tile_schedule_options();
}
inline const ::tc::SchedulerOptionsProto& MappingOptionsProto::intra_tile_schedule_options() const {
  const ::tc::SchedulerOptionsProto* p = intra_tile_schedule_options_;
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.intra_tile_schedule_options)
  return p != NULL ? *p : *reinterpret_cast<const ::tc::SchedulerOptionsProto*>(
      &::tc::_SchedulerOptionsProto_default_instance_);
}
inline ::tc::SchedulerOptionsProto* MappingOptionsProto::mutable_intra_tile_schedule_options() {
  set_has_intra_tile_schedule_options();
  if (intra_tile_schedule_options_ == NULL) {
    intra_tile_schedule_options_ = new ::tc::SchedulerOptionsProto;
  }
  // @@protoc_insertion_point(field_mutable:tc.MappingOptionsProto.intra_tile_schedule_options)
  return intra_tile_schedule_options_;
}
inline ::tc::SchedulerOptionsProto* MappingOptionsProto::release_intra_tile_schedule_options() {
  // @@protoc_insertion_point(field_release:tc.MappingOptionsProto.intra_tile_schedule_options)
  clear_has_intra_tile_schedule_options();
  ::tc::SchedulerOptionsProto* temp = intra_tile_schedule_options_;
  intra_tile_schedule_options_ = NULL;
  return temp;
}
inline void MappingOptionsProto::set_allocated_intra_tile_schedule_options(::tc::SchedulerOptionsProto* intra_tile_schedule_options) {
  delete intra_tile_schedule_options_;
  intra_tile_schedule_options_ = intra_tile_schedule_options;
  if (intra_tile_schedule_options) {
    set_has_intra_tile_schedule_options();
  } else {
    clear_has_intra_tile_schedule_options();
  }
  // @@protoc_insertion_point(field_set_allocated:tc.MappingOptionsProto.intra_tile_schedule_options)
}

// required bool fix_parameters_before_scheduling = 3;
inline bool MappingOptionsProto::has_fix_parameters_before_scheduling() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MappingOptionsProto::set_has_fix_parameters_before_scheduling() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MappingOptionsProto::clear_has_fix_parameters_before_scheduling() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MappingOptionsProto::clear_fix_parameters_before_scheduling() {
  fix_parameters_before_scheduling_ = false;
  clear_has_fix_parameters_before_scheduling();
}
inline bool MappingOptionsProto::fix_parameters_before_scheduling() const {
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.fix_parameters_before_scheduling)
  return fix_parameters_before_scheduling_;
}
inline void MappingOptionsProto::set_fix_parameters_before_scheduling(bool value) {
  set_has_fix_parameters_before_scheduling();
  fix_parameters_before_scheduling_ = value;
  // @@protoc_insertion_point(field_set:tc.MappingOptionsProto.fix_parameters_before_scheduling)
}

// optional .tc.TilingProto tiling = 4;
inline bool MappingOptionsProto::has_tiling() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MappingOptionsProto::set_has_tiling() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MappingOptionsProto::clear_has_tiling() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MappingOptionsProto::clear_tiling() {
  if (tiling_ != NULL) tiling_->::tc::TilingProto::Clear();
  clear_has_tiling();
}
inline const ::tc::TilingProto& MappingOptionsProto::tiling() const {
  const ::tc::TilingProto* p = tiling_;
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.tiling)
  return p != NULL ? *p : *reinterpret_cast<const ::tc::TilingProto*>(
      &::tc::_TilingProto_default_instance_);
}
inline ::tc::TilingProto* MappingOptionsProto::mutable_tiling() {
  set_has_tiling();
  if (tiling_ == NULL) {
    tiling_ = new ::tc::TilingProto;
  }
  // @@protoc_insertion_point(field_mutable:tc.MappingOptionsProto.tiling)
  return tiling_;
}
inline ::tc::TilingProto* MappingOptionsProto::release_tiling() {
  // @@protoc_insertion_point(field_release:tc.MappingOptionsProto.tiling)
  clear_has_tiling();
  ::tc::TilingProto* temp = tiling_;
  tiling_ = NULL;
  return temp;
}
inline void MappingOptionsProto::set_allocated_tiling(::tc::TilingProto* tiling) {
  delete tiling_;
  tiling_ = tiling;
  if (tiling) {
    set_has_tiling();
  } else {
    clear_has_tiling();
  }
  // @@protoc_insertion_point(field_set_allocated:tc.MappingOptionsProto.tiling)
}

// required .tc.CudaDimProto block = 5;
inline bool MappingOptionsProto::has_block() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MappingOptionsProto::set_has_block() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MappingOptionsProto::clear_has_block() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MappingOptionsProto::clear_block() {
  if (block_ != NULL) block_->::tc::CudaDimProto::Clear();
  clear_has_block();
}
inline const ::tc::CudaDimProto& MappingOptionsProto::block() const {
  const ::tc::CudaDimProto* p = block_;
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.block)
  return p != NULL ? *p : *reinterpret_cast<const ::tc::CudaDimProto*>(
      &::tc::_CudaDimProto_default_instance_);
}
inline ::tc::CudaDimProto* MappingOptionsProto::mutable_block() {
  set_has_block();
  if (block_ == NULL) {
    block_ = new ::tc::CudaDimProto;
  }
  // @@protoc_insertion_point(field_mutable:tc.MappingOptionsProto.block)
  return block_;
}
inline ::tc::CudaDimProto* MappingOptionsProto::release_block() {
  // @@protoc_insertion_point(field_release:tc.MappingOptionsProto.block)
  clear_has_block();
  ::tc::CudaDimProto* temp = block_;
  block_ = NULL;
  return temp;
}
inline void MappingOptionsProto::set_allocated_block(::tc::CudaDimProto* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
  // @@protoc_insertion_point(field_set_allocated:tc.MappingOptionsProto.block)
}

// required .tc.CudaDimProto grid = 6;
inline bool MappingOptionsProto::has_grid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MappingOptionsProto::set_has_grid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MappingOptionsProto::clear_has_grid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MappingOptionsProto::clear_grid() {
  if (grid_ != NULL) grid_->::tc::CudaDimProto::Clear();
  clear_has_grid();
}
inline const ::tc::CudaDimProto& MappingOptionsProto::grid() const {
  const ::tc::CudaDimProto* p = grid_;
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.grid)
  return p != NULL ? *p : *reinterpret_cast<const ::tc::CudaDimProto*>(
      &::tc::_CudaDimProto_default_instance_);
}
inline ::tc::CudaDimProto* MappingOptionsProto::mutable_grid() {
  set_has_grid();
  if (grid_ == NULL) {
    grid_ = new ::tc::CudaDimProto;
  }
  // @@protoc_insertion_point(field_mutable:tc.MappingOptionsProto.grid)
  return grid_;
}
inline ::tc::CudaDimProto* MappingOptionsProto::release_grid() {
  // @@protoc_insertion_point(field_release:tc.MappingOptionsProto.grid)
  clear_has_grid();
  ::tc::CudaDimProto* temp = grid_;
  grid_ = NULL;
  return temp;
}
inline void MappingOptionsProto::set_allocated_grid(::tc::CudaDimProto* grid) {
  delete grid_;
  grid_ = grid;
  if (grid) {
    set_has_grid();
  } else {
    clear_has_grid();
  }
  // @@protoc_insertion_point(field_set_allocated:tc.MappingOptionsProto.grid)
}

// optional uint64 unroll = 7;
inline bool MappingOptionsProto::has_unroll() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MappingOptionsProto::set_has_unroll() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MappingOptionsProto::clear_has_unroll() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MappingOptionsProto::clear_unroll() {
  unroll_ = GOOGLE_ULONGLONG(0);
  clear_has_unroll();
}
inline ::google::protobuf::uint64 MappingOptionsProto::unroll() const {
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.unroll)
  return unroll_;
}
inline void MappingOptionsProto::set_unroll(::google::protobuf::uint64 value) {
  set_has_unroll();
  unroll_ = value;
  // @@protoc_insertion_point(field_set:tc.MappingOptionsProto.unroll)
}

// required bool tile_imperfectly_nested = 8;
inline bool MappingOptionsProto::has_tile_imperfectly_nested() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MappingOptionsProto::set_has_tile_imperfectly_nested() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MappingOptionsProto::clear_has_tile_imperfectly_nested() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MappingOptionsProto::clear_tile_imperfectly_nested() {
  tile_imperfectly_nested_ = false;
  clear_has_tile_imperfectly_nested();
}
inline bool MappingOptionsProto::tile_imperfectly_nested() const {
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.tile_imperfectly_nested)
  return tile_imperfectly_nested_;
}
inline void MappingOptionsProto::set_tile_imperfectly_nested(bool value) {
  set_has_tile_imperfectly_nested();
  tile_imperfectly_nested_ = value;
  // @@protoc_insertion_point(field_set:tc.MappingOptionsProto.tile_imperfectly_nested)
}

// required bool use_shared_memory = 9;
inline bool MappingOptionsProto::has_use_shared_memory() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MappingOptionsProto::set_has_use_shared_memory() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MappingOptionsProto::clear_has_use_shared_memory() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MappingOptionsProto::clear_use_shared_memory() {
  use_shared_memory_ = false;
  clear_has_use_shared_memory();
}
inline bool MappingOptionsProto::use_shared_memory() const {
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.use_shared_memory)
  return use_shared_memory_;
}
inline void MappingOptionsProto::set_use_shared_memory(bool value) {
  set_has_use_shared_memory();
  use_shared_memory_ = value;
  // @@protoc_insertion_point(field_set:tc.MappingOptionsProto.use_shared_memory)
}

// required bool use_private_memory = 10;
inline bool MappingOptionsProto::has_use_private_memory() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MappingOptionsProto::set_has_use_private_memory() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MappingOptionsProto::clear_has_use_private_memory() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MappingOptionsProto::clear_use_private_memory() {
  use_private_memory_ = false;
  clear_has_use_private_memory();
}
inline bool MappingOptionsProto::use_private_memory() const {
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.use_private_memory)
  return use_private_memory_;
}
inline void MappingOptionsProto::set_use_private_memory(bool value) {
  set_has_use_private_memory();
  use_private_memory_ = value;
  // @@protoc_insertion_point(field_set:tc.MappingOptionsProto.use_private_memory)
}

// required bool unroll_copy_shared = 11;
inline bool MappingOptionsProto::has_unroll_copy_shared() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MappingOptionsProto::set_has_unroll_copy_shared() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MappingOptionsProto::clear_has_unroll_copy_shared() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MappingOptionsProto::clear_unroll_copy_shared() {
  unroll_copy_shared_ = false;
  clear_has_unroll_copy_shared();
}
inline bool MappingOptionsProto::unroll_copy_shared() const {
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.unroll_copy_shared)
  return unroll_copy_shared_;
}
inline void MappingOptionsProto::set_unroll_copy_shared(bool value) {
  set_has_unroll_copy_shared();
  unroll_copy_shared_ = value;
  // @@protoc_insertion_point(field_set:tc.MappingOptionsProto.unroll_copy_shared)
}

// optional uint64 max_shared_memory = 12;
inline bool MappingOptionsProto::has_max_shared_memory() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MappingOptionsProto::set_has_max_shared_memory() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MappingOptionsProto::clear_has_max_shared_memory() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MappingOptionsProto::clear_max_shared_memory() {
  max_shared_memory_ = GOOGLE_ULONGLONG(0);
  clear_has_max_shared_memory();
}
inline ::google::protobuf::uint64 MappingOptionsProto::max_shared_memory() const {
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.max_shared_memory)
  return max_shared_memory_;
}
inline void MappingOptionsProto::set_max_shared_memory(::google::protobuf::uint64 value) {
  set_has_max_shared_memory();
  max_shared_memory_ = value;
  // @@protoc_insertion_point(field_set:tc.MappingOptionsProto.max_shared_memory)
}

// required bool match_library_calls = 14;
inline bool MappingOptionsProto::has_match_library_calls() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MappingOptionsProto::set_has_match_library_calls() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MappingOptionsProto::clear_has_match_library_calls() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MappingOptionsProto::clear_match_library_calls() {
  match_library_calls_ = false;
  clear_has_match_library_calls();
}
inline bool MappingOptionsProto::match_library_calls() const {
  // @@protoc_insertion_point(field_get:tc.MappingOptionsProto.match_library_calls)
  return match_library_calls_;
}
inline void MappingOptionsProto::set_match_library_calls(bool value) {
  set_has_match_library_calls();
  match_library_calls_ = value;
  // @@protoc_insertion_point(field_set:tc.MappingOptionsProto.match_library_calls)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace tc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tc::FusionStrategy> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tc::FusionStrategy>() {
  return ::tc::FusionStrategy_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mapping_5foptions_2eproto__INCLUDED
